#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <conio.h>

int map[20][20] =
{
	{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
	{ -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, -1 },
	{ -1, 0, -1, 0, -1, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 0, 0, -1, 0, -1 },
	{ -1, -1, -1, 0, 0, 0, -1, 0, 0, -1, 0, -1, -1, -1, 0, -1, -1, -1, 0, -1 },
	{ -1, 0, 0, 0, -1, 0, -1, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, -1 },
	{ -1, 0, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1, 0, -1, -1, -1, -1, 0, -1 },
	{ -1, 0, -1, 0, -1, 0, -1, -1, 0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, -1 },
	{ -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1 },
	{ -1, -1, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1 },
	{ -1, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, -1, 0, 0, -1, -1 },
	{ -1, 0, -1, -1, -1, -1, -1, 0, -1, -1, -1, 0, 0, -1, -1, -1, -1, 0, 0, -1 },
	{ -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, -1 },
	{ -1, -1, -1, -1, 0, -1, -1, -1, 0, -1, -1, 0, -1, -1, 0, -1, -1, -1, 0, -1 },
	{ -1, 0, 0, 0, 0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, 0, 0, -1 },
	{ -1, 0, -1, -1, -1, -1, -1, 0, -1, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, -1 },
	{ -1, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, 0, -1 },
	{ -1, -1, -1, 0, -1, 0, -1, -1, -1, 0, -1, -1, -1, 0, 0, 0, 0, 0, 0, -1 },
	{ -1, 0, -1, -1, -1, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, 0, -1 },
	{ -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1 },
	{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
};
//랜덤미로와 수 일치를 시킬것

void square();

int f[20][20];
int banbok = 0;
save[20][20] = { 0, };
//int[i][j] 에서 [i]에 해당하는 부분은 세로줄 [j]에 해당하는 부분은 가로줄
void dfs(int i, int j) {
	f[i][j] = -1;
	//printf("%d, %d %d\n", i, j, banbok);
	banbok = banbok + 1; //DFS를 통해 몇 번째로 칸을 방문했는지 카운트
	save[i][j] = banbok; //카운트 값을 나중에 출력하기 위한 배열
	square();
	if (i - 1 >= 0 && map[i - 1][j] != -1 && f[i - 1][j] == 0) dfs(i - 1, j); //위
	if (j + 1 < 20 && map[i][j + 1] != -1 && f[i][j + 1] == 0) dfs(i, j + 1); //오른쪽
	if (i + 1 < 20 && map[i + 1][j] != -1 && f[i + 1][j] == 0) dfs(i + 1, j); //아래
	if (j - 1 >= 0 && map[i][j - 1] != -1 && f[i][j - 1] == 0) dfs(i, j - 1); //왼쪽
}

void square() { //사각형으로 미로+방법수 출력
	int a, b;
	system("cls");
	for (a = 0; a < 20; a++) // a 너비
	{
		for (b = 0; b < 20; b++) //b 높이
		{
			if (map[a][b] == -1)
			{
				printf(" □"); // -1을 벽으로
			}
			else if (map[a][b] != -1) // BFS를 통해 길이 숫자로 나오므로 -1을 제외한 (아래주석)
			{
				printf("%3d", save[a][b]); // □와 숫자간격을 맞추기 위해 %3d,     모든 숫자에 대해서 그대로 출력
			}
		}
		printf("\n");
	}
}

int main() {
	dfs(1, 1);
	square();
}
